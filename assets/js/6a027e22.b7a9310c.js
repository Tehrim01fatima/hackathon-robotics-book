"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[706],{6796:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-1/lesson-2-python-agents-controllers","title":"Lesson 2 - Python Agents & Controllers - rclpy, Behavior Trees","description":"Learning Objectives","source":"@site/docs/module-1/lesson-2-python-agents-controllers.md","sourceDirName":"module-1","slug":"/module-1/lesson-2-python-agents-controllers","permalink":"/hackathon-robotics-book/docs/module-1/lesson-2-python-agents-controllers","draft":false,"unlisted":false,"editUrl":"https://github.com/Tehrim01fatima/hackathon-robotics-book/edit/main/my-website/docs/module-1/lesson-2-python-agents-controllers.md","tags":[],"version":"current","frontMatter":{"title":"Lesson 2 - Python Agents & Controllers - rclpy, Behavior Trees","sidebar_label":"Python Agents & Controllers"},"sidebar":"textbookSidebar","previous":{"title":"ROS 2 Architecture","permalink":"/hackathon-robotics-book/docs/module-1/lesson-1-ros2-architecture"},"next":{"title":"Humanoid URDF","permalink":"/hackathon-robotics-book/docs/module-1/lesson-3-humanoid-urdf"}}');var r=t(4848),s=t(8453);const i={title:"Lesson 2 - Python Agents & Controllers - rclpy, Behavior Trees",sidebar_label:"Python Agents & Controllers"},l="Lesson 2: Python Agents & Controllers - rclpy, Behavior Trees",a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"rclpy Architecture Overview",id:"rclpy-architecture-overview",level:2},{value:"rclpy: Python Client Library for ROS 2",id:"rclpy-python-client-library-for-ros-2",level:2},{value:"Basic Node Structure with rclpy",id:"basic-node-structure-with-rclpy",level:3},{value:"Advanced rclpy Features",id:"advanced-rclpy-features",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Custom Message Types",id:"custom-message-types",level:4},{value:"Behavior Trees for Complex Robot Behaviors",id:"behavior-trees-for-complex-robot-behaviors",level:2},{value:"Behavior Tree Fundamentals",id:"behavior-tree-fundamentals",level:3},{value:"Implementing Behavior Trees in Python",id:"implementing-behavior-trees-in-python",level:3},{value:"Behavior Tree Example: Humanoid Walking",id:"behavior-tree-example-humanoid-walking",level:3},{value:"Advanced Controller Design",id:"advanced-controller-design",level:2},{value:"PID Controllers for Joint Control",id:"pid-controllers-for-joint-control",level:3},{value:"Model Predictive Control for Humanoid Balance",id:"model-predictive-control-for-humanoid-balance",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Reflection Questions",id:"reflection-questions",level:2},{value:"APA Citations",id:"apa-citations",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"lesson-2-python-agents--controllers---rclpy-behavior-trees",children:"Lesson 2: Python Agents & Controllers - rclpy, Behavior Trees"})}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement ROS 2 nodes using the rclpy client library for Python"}),"\n",(0,r.jsx)(n.li,{children:"Design and implement behavior trees for complex humanoid robot behaviors"}),"\n",(0,r.jsx)(n.li,{children:"Create custom controllers for humanoid robot joints and movements"}),"\n",(0,r.jsx)(n.li,{children:"Integrate perception and action systems using Python agents"}),"\n",(0,r.jsx)(n.li,{children:"Implement reactive and deliberative control architectures"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(n.p,{children:"Python has become the de facto language for robotics development due to its simplicity, extensive libraries, and strong community support. In ROS 2, the rclpy library provides Python bindings that allow developers to create ROS 2 nodes, publish and subscribe to topics, call services, and execute actions. Combined with behavior trees for organizing complex behaviors, Python becomes a powerful tool for implementing humanoid robot control systems."}),"\n",(0,r.jsx)(n.p,{children:"This lesson will explore how to build sophisticated Python agents that can control humanoid robots, process sensor data, and execute complex behaviors using the ROS 2 framework and behavior tree architectures."}),"\n",(0,r.jsx)(n.h2,{id:"rclpy-architecture-overview",children:"rclpy Architecture Overview"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mermaid",children:"graph TB\n    A[Python Application] --\x3e B[rclpy]\n    B --\x3e C{ROS 2 Client Library}\n    C --\x3e D[Node Creation]\n    C --\x3e E[Publisher/Subscriber]\n    C --\x3e F[Service/Action]\n    C --\x3e G[Parameter Management]\n\n    D --\x3e H[HumanoidController Node]\n    E --\x3e I[Joint Command Publisher]\n    E --\x3e J[Sensor Data Subscriber]\n    F --\x3e K[Balance Service Client]\n    G --\x3e L[Control Frequency Parameter]\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Figure 1: rclpy architecture showing the relationship between Python applications and ROS 2 functionality."})}),"\n",(0,r.jsx)(n.h2,{id:"rclpy-python-client-library-for-ros-2",children:"rclpy: Python Client Library for ROS 2"}),"\n",(0,r.jsx)(n.p,{children:"rclpy (ROS Client Library for Python) is the Python interface to ROS 2. It provides all the necessary functionality to create ROS 2 nodes, interact with the ROS 2 middleware, and communicate with other nodes in the system."}),"\n",(0,r.jsx)(n.h3,{id:"basic-node-structure-with-rclpy",children:"Basic Node Structure with rclpy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\nclass HumanoidController(Node):\n    def __init__(self):\n        super().__init__('humanoid_controller')\n\n        # Create publishers, subscribers, services, and actions\n        self.joint_command_publisher = self.create_publisher(\n            JointCommand,\n            '/joint_commands',\n            10\n        )\n\n        self.sensor_subscription = self.create_subscription(\n            SensorData,\n            '/sensor_data',\n            self.sensor_callback,\n            10\n        )\n\n        # Create a timer for control loop\n        self.control_timer = self.create_timer(0.01, self.control_loop)  # 100Hz\n\n        self.get_logger().info('Humanoid Controller initialized')\n\n    def sensor_callback(self, msg):\n        # Process sensor data\n        self.get_logger().info(f'Received sensor data: {msg.data}')\n\n    def control_loop(self):\n        # Implement control logic here\n        pass\n\ndef main(args=None):\n    rclpy.init(args=args)\n    controller = HumanoidController()\n    rclpy.spin(controller)\n    controller.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"advanced-rclpy-features",children:"Advanced rclpy Features"}),"\n",(0,r.jsx)(n.p,{children:"rclpy provides several advanced features that are particularly useful for humanoid robotics:"}),"\n",(0,r.jsx)(n.h4,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsx)(n.p,{children:"Parameters allow runtime configuration of node behavior:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.parameter import Parameter\n\nclass ConfigurableController(Node):\n    def __init__(self):\n        super().__init__('configurable_controller')\n\n        # Declare parameters with default values\n        self.declare_parameter('control_frequency', 100)\n        self.declare_parameter('max_joint_velocity', 1.0)\n        self.declare_parameter('safety_threshold', 0.8)\n\n        # Access parameter values\n        self.control_freq = self.get_parameter('control_frequency').value\n        self.max_velocity = self.get_parameter('max_joint_velocity').value\n        self.safety_threshold = self.get_parameter('safety_threshold').value\n\n        # Create timer based on parameter\n        self.control_timer = self.create_timer(\n            1.0 / self.control_freq,\n            self.control_loop\n        )\n\n        # Add callback for parameter changes\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n    def parameter_callback(self, params):\n        for param in params:\n            if param.name == 'control_frequency':\n                # Adjust timer if frequency changes\n                self.control_freq = param.value\n                self.control_timer.timer_period_ns = int(1e9 / self.control_freq)\n        return SetParametersResult(successful=True)\n\n    def control_loop(self):\n        # Use parameter values in control logic\n        pass\n"})}),"\n",(0,r.jsx)(n.h4,{id:"custom-message-types",children:"Custom Message Types"}),"\n",(0,r.jsx)(n.p,{children:"For humanoid robots, you'll often need custom message types to represent joint commands, sensor data, and robot states:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Define custom message in msg/HumanoidState.msg\n# float64[] joint_positions\n# float64[] joint_velocities\n# float64[] joint_torques\n# geometry_msgs/Point center_of_mass\n# bool in_balance\n\nfrom my_robot_msgs.msg import HumanoidState\n\nclass StatePublisher(Node):\n    def __init__(self):\n        super().__init__('state_publisher')\n        self.state_publisher = self.create_publisher(\n            HumanoidState,\n            'humanoid_state',\n            10\n        )\n        self.timer = self.create_timer(0.01, self.publish_state)\n\n    def publish_state(self):\n        msg = HumanoidState()\n        # Populate message with current robot state\n        msg.joint_positions = self.get_joint_positions()\n        msg.center_of_mass = self.calculate_com()\n        msg.in_balance = self.check_balance()\n\n        self.state_publisher.publish(msg)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"behavior-trees-for-complex-robot-behaviors",children:"Behavior Trees for Complex Robot Behaviors"}),"\n",(0,r.jsx)(n.p,{children:"Behavior trees are a powerful tool for organizing complex robot behaviors. They provide a modular, hierarchical approach to behavior design that is more maintainable than traditional finite state machines, especially for humanoid robots with complex interaction patterns."}),"\n",(0,r.jsx)(n.h3,{id:"behavior-tree-fundamentals",children:"Behavior Tree Fundamentals"}),"\n",(0,r.jsx)(n.p,{children:"Behavior trees consist of nodes that return one of three states:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Success"}),": The behavior completed successfully"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Failure"}),": The behavior failed to complete"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Running"}),": The behavior is still executing"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The main types of nodes are:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Composites"}),": Control the flow of execution (Sequence, Selector, Parallel)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Decorators"}),": Modify the behavior of child nodes (Inverter, Retry, Timeout)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Leaf nodes"}),": Execute specific actions or conditions"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    A[Root Node] --\x3e B[Selector]\n    A --\x3e C[Sequence]\n    B --\x3e D[Condition: Balance OK?]\n    B --\x3e E[Action: Adjust Balance]\n    C --\x3e F[Action: Step Forward]\n    C --\x3e G[Condition: Target Reached?]\n\n    D --\x3e|True| H[Action: Walk]\n    D --\x3e|False| E\n    G --\x3e|False| F\n    G --\x3e|True| I[Action: Stop Walking]\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Figure 2: Example behavior tree structure for humanoid walking behavior."})}),"\n",(0,r.jsx)(n.h3,{id:"implementing-behavior-trees-in-python",children:"Implementing Behavior Trees in Python"}),"\n",(0,r.jsx)(n.p,{children:"Let's implement a simple behavior tree framework for humanoid robots:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from enum import Enum\nfrom abc import ABC, abstractmethod\n\nclass NodeStatus(Enum):\n    SUCCESS = "success"\n    FAILURE = "failure"\n    RUNNING = "running"\n\nclass BehaviorNode(ABC):\n    def __init__(self, name):\n        self.name = name\n        self.status = NodeStatus.RUNNING\n\n    @abstractmethod\n    def tick(self):\n        pass\n\nclass ActionNode(BehaviorNode):\n    def __init__(self, name, action_func):\n        super().__init__(name)\n        self.action_func = action_func\n\n    def tick(self):\n        return self.action_func()\n\nclass ConditionNode(BehaviorNode):\n    def __init__(self, name, condition_func):\n        super().__init__(name)\n        self.condition_func = condition_func\n\n    def tick(self):\n        result = self.condition_func()\n        return NodeStatus.SUCCESS if result else NodeStatus.FAILURE\n\nclass SequenceNode(BehaviorNode):\n    def __init__(self, name, children):\n        super().__init__(name)\n        self.children = children\n        self.current_child_idx = 0\n\n    def tick(self):\n        while self.current_child_idx < len(self.children):\n            child_status = self.children[self.current_child_idx].tick()\n\n            if child_status == NodeStatus.FAILURE:\n                self.current_child_idx = 0\n                return NodeStatus.FAILURE\n            elif child_status == NodeStatus.RUNNING:\n                return NodeStatus.RUNNING\n            elif child_status == NodeStatus.SUCCESS:\n                self.current_child_idx += 1\n\n        # All children succeeded\n        self.current_child_idx = 0\n        return NodeStatus.SUCCESS\n\nclass SelectorNode(BehaviorNode):\n    def __init__(self, name, children):\n        super().__init__(name)\n        self.children = children\n        self.current_child_idx = 0\n\n    def tick(self):\n        while self.current_child_idx < len(self.children):\n            child_status = self.children[self.current_child_idx].tick()\n\n            if child_status == NodeStatus.SUCCESS:\n                self.current_child_idx = 0\n                return NodeStatus.SUCCESS\n            elif child_status == NodeStatus.RUNNING:\n                return NodeStatus.RUNNING\n            elif child_status == NodeStatus.FAILURE:\n                self.current_child_idx += 1\n\n        # All children failed\n        self.current_child_idx = 0\n        return NodeStatus.FAILURE\n'})}),"\n",(0,r.jsx)(n.h3,{id:"behavior-tree-example-humanoid-walking",children:"Behavior Tree Example: Humanoid Walking"}),"\n",(0,r.jsx)(n.p,{children:"Here's how to implement a behavior tree for humanoid walking:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom builtin_interfaces.msg import Duration\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\n\nclass WalkingBehaviorTree(Node):\n    def __init__(self):\n        super().__init__(\'walking_behavior_tree\')\n\n        # Publishers for joint control\n        self.trajectory_publisher = self.create_publisher(\n            JointTrajectory,\n            \'/joint_trajectory_controller/joint_trajectory\',\n            10\n        )\n\n        # Subscribers for sensor feedback\n        self.imu_subscription = self.create_subscription(\n            Imu,\n            \'/imu/data\',\n            self.imu_callback,\n            10\n        )\n\n        # Initialize behavior tree\n        self.init_behavior_tree()\n\n        # Timer for behavior tree execution\n        self.bt_timer = self.create_timer(0.1, self.execute_behavior_tree)\n\n        self.imu_data = None\n        self.balance_threshold = 0.2\n\n    def init_behavior_tree(self):\n        """Initialize the walking behavior tree"""\n        # Conditions\n        self.balance_ok = ConditionNode(\n            "balance_ok",\n            self.check_balance\n        )\n\n        self.target_reached = ConditionNode(\n            "target_reached",\n            self.check_target_reached\n        )\n\n        # Actions\n        self.step_forward = ActionNode(\n            "step_forward",\n            self.execute_step\n        )\n\n        self.adjust_balance = ActionNode(\n            "adjust_balance",\n            self.adjust_balance_action\n        )\n\n        self.stop_walking = ActionNode(\n            "stop_walking",\n            self.stop_walking_action\n        )\n\n        # Behavior tree structure\n        # If balance is OK and target not reached, step forward\n        # Otherwise, adjust balance or stop\n        self.walk_sequence = SequenceNode(\n            "walk_sequence",\n            [self.balance_ok, self.step_forward]\n        )\n\n        self.balance_sequence = SequenceNode(\n            "balance_sequence",\n            [self.adjust_balance]\n        )\n\n        self.main_selector = SelectorNode(\n            "main_selector",\n            [self.walk_sequence, self.balance_sequence]\n        )\n\n    def execute_behavior_tree(self):\n        """Execute the behavior tree"""\n        status = self.main_selector.tick()\n        self.get_logger().debug(f\'Behavior tree status: {status}\')\n\n    def check_balance(self):\n        """Check if robot is within balance limits"""\n        if self.imu_data is None:\n            return False\n\n        # Check if roll and pitch are within safe limits\n        roll = self.imu_data.orientation.x\n        pitch = self.imu_data.orientation.y\n\n        return abs(roll) < self.balance_threshold and abs(pitch) < self.balance_threshold\n\n    def check_target_reached(self):\n        """Check if walking target has been reached"""\n        # Implementation would check current position vs target\n        return False  # Simplified for example\n\n    def execute_step(self):\n        """Execute a single walking step"""\n        # Generate trajectory for next step\n        trajectory = JointTrajectory()\n        trajectory.joint_names = [\n            \'left_hip\', \'left_knee\', \'left_ankle\',\n            \'right_hip\', \'right_knee\', \'right_ankle\'\n        ]\n\n        point = JointTrajectoryPoint()\n        # Calculate next step positions (simplified)\n        point.positions = [0.1, 0.2, 0.0, -0.1, -0.2, 0.0]\n        point.time_from_start = Duration(sec=0, nanosec=500000000)  # 0.5 seconds\n\n        trajectory.points.append(point)\n        self.trajectory_publisher.publish(trajectory)\n\n        return NodeStatus.SUCCESS\n\n    def adjust_balance_action(self):\n        """Adjust robot balance"""\n        # Implement balance adjustment logic\n        self.get_logger().info(\'Adjusting balance...\')\n        return NodeStatus.SUCCESS\n\n    def stop_walking_action(self):\n        """Stop walking behavior"""\n        self.get_logger().info(\'Stopping walking behavior\')\n        return NodeStatus.SUCCESS\n\n    def imu_callback(self, msg):\n        self.imu_data = msg\n'})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-controller-design",children:"Advanced Controller Design"}),"\n",(0,r.jsx)(n.h3,{id:"pid-controllers-for-joint-control",children:"PID Controllers for Joint Control"}),"\n",(0,r.jsx)(n.p,{children:"For precise control of humanoid robot joints, PID (Proportional-Integral-Derivative) controllers are commonly used:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class JointPIDController:\n    def __init__(self, kp=1.0, ki=0.1, kd=0.05, dt=0.01):\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n        self.dt = dt\n\n        self.prev_error = 0.0\n        self.integral = 0.0\n\n    def compute(self, target_position, current_position):\n        error = target_position - current_position\n\n        # Proportional term\n        p_term = self.kp * error\n\n        # Integral term\n        self.integral += error * self.dt\n        i_term = self.ki * self.integral\n\n        # Derivative term\n        derivative = (error - self.prev_error) / self.dt\n        d_term = self.kd * derivative\n\n        # Store error for next iteration\n        self.prev_error = error\n\n        # Compute output\n        output = p_term + i_term + d_term\n\n        return output\n\n```mermaid\ngraph LR\n    A[Target Position] --\x3e D[Error Calculator]\n    B[Current Position] --\x3e D\n    D --\x3e E[Error]\n    E --\x3e F[Proportional Gain]\n    E --\x3e G[Integral Calculator]\n    E --\x3e H[Derivative Calculator]\n    F --\x3e I[Kp]\n    G --\x3e J[Ki]\n    H --\x3e K[Kd]\n    I --\x3e L[Proportional Term]\n    J --\x3e M[Integral Term]\n    K --\x3e N[Derivative Term]\n    L --\x3e O[Sum]\n    M --\x3e O\n    N --\x3e O\n    O --\x3e P[Control Output]\n    P --\x3e Q[Joint Actuator]\n    Q --\x3e B\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Figure 3: PID controller diagram showing the feedback control loop for joint position control."})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class JointControllerNode(Node):\n    def __init__(self):\n        super().__init__('joint_controller')\n\n        # Create PID controllers for each joint\n        self.joint_controllers = {\n            'left_hip': JointPIDController(kp=2.0, ki=0.5, kd=0.1),\n            'right_hip': JointPIDController(kp=2.0, ki=0.5, kd=0.1),\n            'left_knee': JointPIDController(kp=1.5, ki=0.3, kd=0.08),\n            'right_knee': JointPIDController(kp=1.5, ki=0.3, kd=0.08),\n        }\n\n        # Publishers and subscribers\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        self.joint_command_pub = self.create_publisher(\n            JointCommand,\n            '/joint_commands',\n            10\n        )\n\n        self.target_sub = self.create_subscription(\n            JointState,\n            '/joint_targets',\n            self.target_callback,\n            10\n        )\n\n        self.control_timer = self.create_timer(0.01, self.control_loop)\n\n        self.current_positions = {}\n        self.target_positions = {}\n\n    def joint_state_callback(self, msg):\n        for name, pos in zip(msg.name, msg.position):\n            self.current_positions[name] = pos\n\n    def target_callback(self, msg):\n        for name, pos in zip(msg.name, msg.position):\n            self.target_positions[name] = pos\n\n    def control_loop(self):\n        if not self.current_positions or not self.target_positions:\n            return\n\n        command_msg = JointCommand()\n        command_msg.name = []\n        command_msg.effort = []  # Using effort control\n\n        for joint_name in self.joint_controllers:\n            if (joint_name in self.current_positions and\n                joint_name in self.target_positions):\n\n                current_pos = self.current_positions[joint_name]\n                target_pos = self.target_positions[joint_name]\n\n                # Compute control effort using PID\n                effort = self.joint_controllers[joint_name].compute(\n                    target_pos,\n                    current_pos\n                )\n\n                command_msg.name.append(joint_name)\n                command_msg.effort.append(effort)\n\n        self.joint_command_pub.publish(command_msg)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"model-predictive-control-for-humanoid-balance",children:"Model Predictive Control for Humanoid Balance"}),"\n",(0,r.jsx)(n.p,{children:"For more sophisticated control, Model Predictive Control (MPC) can be used to predict and optimize future behavior:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom scipy.optimize import minimize\n\nclass MPCBalanceController:\n    def __init__(self, horizon=10, dt=0.1):\n        self.horizon = horizon  # Prediction horizon\n        self.dt = dt\n        self.nx = 4  # State: [x, vx, y, vy] (CoM position and velocity)\n        self.nu = 2  # Control: [Fx, Fy] (forces in x and y)\n\n    def predict_dynamics(self, state, control, dt):\n        """Simple inverted pendulum dynamics"""\n        x, vx, y, vy = state\n        fx, fy = control\n\n        # Simplified dynamics: double integrator with gravity compensation\n        new_vx = vx + fx * dt\n        new_x = x + new_vx * dt\n\n        new_vy = vy + fy * dt\n        new_y = y + new_vy * dt\n\n        return np.array([new_x, new_vx, new_y, new_vy])\n\n    def cost_function(self, controls_flat, initial_state, reference_trajectory):\n        """Cost function for MPC optimization"""\n        controls = controls_flat.reshape((self.horizon, self.nu))\n        state = initial_state.copy()\n\n        total_cost = 0.0\n\n        for k in range(self.horizon):\n            # Predict next state\n            state = self.predict_dynamics(state, controls[k], self.dt)\n\n            # Tracking cost\n            state_error = state - reference_trajectory[k]\n            tracking_cost = np.dot(state_error, state_error)\n\n            # Control effort cost\n            control_cost = np.dot(controls[k], controls[k])\n\n            total_cost += tracking_cost + 0.1 * control_cost\n\n        return total_cost\n\n    def solve_mpc(self, current_state, reference_trajectory):\n        """Solve MPC optimization problem"""\n        # Initial guess for controls\n        initial_controls = np.zeros(self.horizon * self.nu)\n\n        # Constraints (simplified - in practice you\'d have more complex constraints)\n        constraints = []\n\n        # Bounds on controls (force limits)\n        bounds = [(-50, 50)] * (self.horizon * self.nu)  # \xb150N force limits\n\n        # Optimize\n        result = minimize(\n            self.cost_function,\n            initial_controls,\n            args=(current_state, reference_trajectory),\n            method=\'SLSQP\',\n            bounds=bounds,\n            constraints=constraints\n        )\n\n        if result.success:\n            optimal_controls = result.x.reshape((self.horizon, self.nu))\n            # Return first control action\n            return optimal_controls[0]\n        else:\n            # Return zero control if optimization failed\n            return np.zeros(self.nu)\n\nclass MPCBalanceNode(Node):\n    def __init__(self):\n        super().__init__(\'mpc_balance_controller\')\n\n        self.mpc_controller = MPCBalanceController()\n\n        # Subscriptions\n        self.imu_sub = self.create_subscription(\n            Imu, \'/imu/data\', self.imu_callback, 10\n        )\n\n        self.force_pub = self.create_publisher(\n            Wrench, \'/balance_forces\', 10\n        )\n\n        self.control_timer = self.create_timer(0.05, self.mpc_control_loop)\n\n        self.current_state = np.zeros(4)  # [x, vx, y, vy]\n        self.reference_trajectory = np.zeros((10, 4))  # Future reference states\n\n```mermaid\ngraph TD\n    A[Current State Measurement] --\x3e B[Prediction Model]\n    B --\x3e C[Future State Predictions]\n    C --\x3e D[Cost Function Evaluation]\n    D --\x3e E[Optimization Solver]\n    E --\x3e F[Optimal Control Sequence]\n    F --\x3e G[Apply First Control]\n    G --\x3e H[Next Time Step]\n    H --\x3e B\n    I[Reference Trajectory] --\x3e D\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Figure 4: Model Predictive Control loop showing the receding horizon optimization process."})}),"\n",(0,r.jsx)(n.p,{children:"def imu_callback(self, msg):"}),"\n",(0,r.jsx)(n.h1,{id:"update-current-state-from-imu-and-other-sensors",children:"Update current state from IMU and other sensors"}),"\n",(0,r.jsx)(n.h1,{id:"this-is-simplified---in-practice-youd-fuse-multiple-sensors",children:"This is simplified - in practice you'd fuse multiple sensors"}),"\n",(0,r.jsx)(n.p,{children:"pass"}),"\n",(0,r.jsx)(n.p,{children:"def mpc_control_loop(self):"}),"\n",(0,r.jsx)(n.h1,{id:"generate-reference-trajectory-eg-maintain-balance-at-origin",children:"Generate reference trajectory (e.g., maintain balance at origin)"}),"\n",(0,r.jsx)(n.p,{children:"self.reference_trajectory = np.zeros((10, 4))"}),"\n",(0,r.jsx)(n.h1,{id:"solve-mpc-problem",children:"Solve MPC problem"}),"\n",(0,r.jsx)(n.p,{children:"optimal_force = self.mpc_controller.solve_mpc(\nself.current_state,\nself.reference_trajectory\n)"}),"\n",(0,r.jsx)(n.h1,{id:"publish-balance-forces",children:"Publish balance forces"}),"\n",(0,r.jsx)(n.p,{children:"force_msg = Wrench()\nforce_msg.force.x = optimal_force[0]\nforce_msg.force.y = optimal_force[1]\nself.force_pub.publish(force_msg)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\n## Hands-on Exercise 2.1: Implement a Simple Behavior Tree\n\nCreate a Python package that implements a behavior tree for a simple humanoid robot task:\n\n1. Create a new package called `humanoid_behavior_trees`:\n```bash\ncd ~/ros2_ws/src\nros2 pkg create --build-type ament_python humanoid_behavior_trees\n"})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:"Create a behavior tree for a humanoid robot to approach an object and grasp it:"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# humanoid_behavior_trees/humanoid_behavior_trees/grasp_behavior.py\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image\nfrom geometry_msgs.msg import Point\nfrom std_msgs.msg import Bool\n\nclass GraspBehavior(Node):\n    def __init__(self):\n        super().__init__('grasp_behavior')\n\n        # Publishers and subscribers\n        self.image_sub = self.create_subscription(\n            Image, '/camera/image_raw', self.image_callback, 10\n        )\n\n        self.grasp_pub = self.create_publisher(Bool, '/execute_grasp', 10)\n        self.approach_pub = self.create_publisher(Point, '/approach_target', 10)\n\n        # Initialize behavior tree\n        self.init_behavior_tree()\n\n        # Timer for behavior execution\n        self.timer = self.create_timer(0.1, self.execute_behavior)\n\n        self.object_detected = False\n        self.object_position = None\n        self.at_approach_position = False\n\n    def init_behavior_tree(self):\n        # Define behavior tree nodes\n        self.detect_object = ConditionNode(\"detect_object\", self.check_object_detected)\n        self.move_to_object = ActionNode(\"move_to_object\", self.execute_approach)\n        self.grasp_object = ActionNode(\"grasp_object\", self.execute_grasp)\n        self.check_position = ConditionNode(\"check_position\", self.check_approach_position)\n\n        # Sequence: detect -> approach -> grasp\n        self.grasp_sequence = SequenceNode(\"grasp_sequence\", [\n            self.detect_object,\n            self.move_to_object,\n            self.check_position,\n            self.grasp_object\n        ])\n\n    def image_callback(self, msg):\n        # Simplified object detection\n        # In practice, you'd use computer vision algorithms\n        self.object_detected = True  # For demonstration\n        self.object_position = Point(x=1.0, y=0.0, z=0.5)  # Detected position\n\n    def check_object_detected(self):\n        return self.object_detected and self.object_position is not None\n\n    def execute_approach(self):\n        if self.object_position:\n            self.approach_pub.publish(self.object_position)\n            self.get_logger().info(f'Approaching object at {self.object_position}')\n            # Simulate approach completion after some time\n            self.at_approach_position = True\n            return NodeStatus.SUCCESS\n        return NodeStatus.FAILURE\n\n    def check_approach_position(self):\n        return self.at_approach_position\n\n    def execute_grasp(self):\n        grasp_msg = Bool()\n        grasp_msg.data = True\n        self.grasp_pub.publish(grasp_msg)\n        self.get_logger().info('Executing grasp')\n        return NodeStatus.SUCCESS\n\n    def execute_behavior(self):\n        status = self.grasp_sequence.tick()\n        self.get_logger().info(f'Grasp behavior status: {status}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = GraspBehavior()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"rclpy"})," provides the Python interface to ROS 2, enabling creation of nodes, publishers, subscribers, services, and actions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Behavior trees"})," offer a modular approach to organizing complex robot behaviors with better maintainability than finite state machines"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"PID controllers"})," are essential for precise joint control in humanoid robots"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Advanced control techniques"})," like Model Predictive Control can improve balance and stability"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parameter management"})," allows runtime configuration of robot behaviors"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom message types"})," enable specialized communication for humanoid-specific data"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"reflection-questions",children:"Reflection Questions"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"How would you modify the behavior tree structure to handle unexpected obstacles during walking?"}),"\n",(0,r.jsx)(n.li,{children:"What are the advantages and disadvantages of using behavior trees versus finite state machines for humanoid robot control?"}),"\n",(0,r.jsx)(n.li,{children:"How might you integrate sensor feedback into the PID control loop to improve performance?"}),"\n",(0,r.jsx)(n.li,{children:"What safety mechanisms would you implement in the behavior tree to prevent dangerous robot states?"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"apa-citations",children:"APA Citations"}),"\n",(0,r.jsxs)(n.p,{children:["Brooks, R. A. (1986). A robust layered control system for a mobile robot. ",(0,r.jsx)(n.em,{children:"IEEE Journal on Robotics and Automation"}),", 2(1), 14-23. ",(0,r.jsx)(n.a,{href:"https://doi.org/10.1109/JRA.1986.1087032",children:"https://doi.org/10.1109/JRA.1986.1087032"})]}),"\n",(0,r.jsxs)(n.p,{children:["Kober, J., Bagnell, J. A., & Peters, J. (2013). Reinforcement learning in robotics: A survey. ",(0,r.jsx)(n.em,{children:"The International Journal of Robotics Research"}),", 32(11), 1238-1274. ",(0,r.jsx)(n.a,{href:"https://doi.org/10.1177/0278364913495721",children:"https://doi.org/10.1177/0278364913495721"})]}),"\n",(0,r.jsxs)(n.p,{children:["Siciliano, B., & Khatib, O. (Eds.). (2016). ",(0,r.jsx)(n.em,{children:"Springer handbook of robotics"})," (2nd ed.). Springer."]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"This lesson explored the implementation of Python agents and controllers for humanoid robots using rclpy and behavior trees. We covered the fundamentals of rclpy for creating ROS 2 nodes, implemented behavior trees for organizing complex behaviors, and demonstrated advanced control techniques including PID and Model Predictive Control. These tools provide the foundation for building sophisticated humanoid robot control systems that can handle complex tasks while maintaining safety and stability."}),"\n",(0,r.jsx)(n.p,{children:"The next lesson will focus on Humanoid URDF (Unified Robot Description Format), where we'll learn how to model humanoid robot structures for simulation and control."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var o=t(6540);const r={},s=o.createContext(r);function i(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);